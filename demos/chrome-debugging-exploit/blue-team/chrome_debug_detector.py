#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Chrome Remote Debugging Detection Tool
BugCon 2025 - Blue Team Defense Script

This script detects Chrome instances running with remote debugging enabled,
which could indicate compromise or misconfiguration.

Author: Your Name
Date: November 2025

Usage:
    python chrome_debug_detector.py
"""

import socket
import subprocess
import requests
import json
import platform
import sys
from typing import List, Dict, Tuple
from datetime import datetime

# Fix Windows console encoding issues
if platform.system() == "Windows":
    try:
        sys.stdout.reconfigure(encoding='utf-8')
    except Exception:
        pass

# Common debugging ports to check
COMMON_DEBUG_PORTS = [9222, 9223, 9224, 9225]

# ANSI color codes for output
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


def print_banner():
    """Print the detection tool banner"""
    print(f"\n{Colors.CYAN}{Colors.BOLD}{'=' * 70}")
    print("Chrome Remote Debugging Detection Tool")
    print("BugCon 2025 - Blue Team Defense")
    print(f"{'=' * 70}{Colors.RESET}\n")


def print_header(text: str):
    """Print a section header"""
    print(f"\n{Colors.BLUE}{Colors.BOLD}[*] {text}{Colors.RESET}")
    print(f"{Colors.BLUE}{'-' * 70}{Colors.RESET}")


def print_success(text: str):
    """Print success message"""
    print(f"{Colors.GREEN}[✓] {text}{Colors.RESET}")


def print_warning(text: str):
    """Print warning message"""
    print(f"{Colors.YELLOW}[!] {text}{Colors.RESET}")


def print_critical(text: str):
    """Print critical finding"""
    print(f"{Colors.RED}{Colors.BOLD}[⚠] {text}{Colors.RESET}")


def print_info(text: str):
    """Print info message"""
    print(f"{Colors.CYAN}[i] {text}{Colors.RESET}")


def check_port_open(port: int) -> bool:
    """Check if a port is open on localhost"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex(('127.0.0.1', port))
    sock.close()
    return result == 0


def scan_debug_ports() -> List[int]:
    """Scan for open Chrome debugging ports"""
    print_header("Scanning for Open Debugging Ports")
    
    open_ports = []
    for port in COMMON_DEBUG_PORTS:
        if check_port_open(port):
            print_critical(f"Port {port} is OPEN - Chrome debugging detected!")
            open_ports.append(port)
        else:
            print_success(f"Port {port} is closed")
    
    return open_ports


def analyze_debug_port(port: int) -> Dict:
    """Analyze a Chrome debugging port to gather information"""
    print_header(f"Analyzing Debug Port {port}")
    
    info = {
        "port": port,
        "accessible": False,
        "version": None,
        "tabs": [],
        "security_origins": []
    }
    
    try:
        # Get Chrome version info
        response = requests.get(f"http://127.0.0.1:{port}/json/version", timeout=3)
        if response.status_code == 200:
            info["accessible"] = True
            version_data = response.json()
            info["version"] = version_data
            
            print_critical(f"Debug API is ACCESSIBLE (NO AUTHENTICATION)")
            print_info(f"    Browser: {version_data.get('Browser', 'Unknown')}")
            print_info(f"    User-Agent: {version_data.get('User-Agent', 'Unknown')[:80]}...")
            print_info(f"    WebKit Version: {version_data.get('WebKit-Version', 'Unknown')}")
            
            # Get list of tabs
            tabs_response = requests.get(f"http://127.0.0.1:{port}/json/list", timeout=3)
            if tabs_response.status_code == 200:
                tabs = tabs_response.json()
                info["tabs"] = tabs
                
                print_warning(f"Found {len(tabs)} accessible target(s):")
                for idx, tab in enumerate(tabs[:5]):  # Show first 5
                    if tab.get('type') == 'page':
                        print_info(f"      [{idx}] {tab.get('title', 'No title')[:60]}")
                        print_info(f"          URL: {tab.get('url', 'Unknown')[:70]}")
                        
                        # Track security origins
                        url = tab.get('url', '')
                        if url.startswith('http'):
                            origin = url.split('/')[2] if len(url.split('/')) > 2 else url
                            if origin not in info["security_origins"]:
                                info["security_origins"].append(origin)
                
                if len(tabs) > 5:
                    print_info(f"      ... and {len(tabs) - 5} more targets")
    
    except requests.exceptions.RequestException as e:
        print_success(f"Debug port {port} exists but API not accessible")
        print_info(f"    (This might be expected if authentication is configured)")
    
    return info


def detect_chrome_processes() -> List[Dict]:
    """Detect Chrome processes with debugging flags"""
    print_header("Detecting Chrome Processes with Debug Flags")
    
    suspicious_processes = []
    
    try:
        if platform.system() == "Windows":
            # Windows: Use PowerShell to get Chrome process command lines
            cmd = 'Get-Process chrome -ErrorAction SilentlyContinue | Select-Object Id,ProcessName,@{Name="CommandLine";Expression={(Get-CimInstance Win32_Process -Filter "ProcessId = $($_.Id)").CommandLine}} | ConvertTo-Json'
            result = subprocess.run(
                ["powershell", "-Command", cmd],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0 and result.stdout.strip():
                try:
                    processes = json.loads(result.stdout)
                    if not isinstance(processes, list):
                        processes = [processes] if processes else []
                    
                    debug_flags = ['--remote-debugging-port', '--debugging-port']
                    
                    for proc in processes:
                        cmdline = proc.get('CommandLine', '')
                        if cmdline and any(flag in cmdline for flag in debug_flags):
                            suspicious_processes.append({
                                'pid': proc.get('Id'),
                                'name': proc.get('ProcessName'),
                                'cmdline': cmdline
                            })
                            print_critical(f"Suspicious Chrome process detected!")
                            print_info(f"    PID: {proc.get('Id')}")
                            print_info(f"    Command: {cmdline[:100]}...")
                    
                    if not suspicious_processes:
                        print_success("No Chrome processes with debug flags detected")
                except json.JSONDecodeError:
                    print_info("No Chrome processes currently running")
            else:
                print_info("No Chrome processes found")
        
        else:
            # Linux/Mac: Use ps command
            result = subprocess.run(
                ["ps", "aux"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            lines = result.stdout.split('\n')
            debug_flags = ['--remote-debugging-port', '--debugging-port']
            
            for line in lines:
                if 'chrome' in line.lower() and any(flag in line for flag in debug_flags):
                    parts = line.split(None, 10)
                    if len(parts) >= 11:
                        suspicious_processes.append({
                            'pid': parts[1],
                            'cmdline': parts[10]
                        })
                        print_critical(f"Suspicious Chrome process detected!")
                        print_info(f"    PID: {parts[1]}")
                        print_info(f"    Command: {parts[10][:100]}...")
            
            if not suspicious_processes:
                print_success("No Chrome processes with debug flags detected")
    
    except Exception as e:
        print_warning(f"Could not enumerate processes: {e}")
    
    return suspicious_processes


def check_network_connections(ports: List[int]) -> List[Dict]:
    """Check for active network connections to debugging ports"""
    print_header("Checking Network Connections")
    
    connections = []
    
    try:
        if platform.system() == "Windows":
            # Use netstat to find connections
            result = subprocess.run(
                ["netstat", "-ano"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            lines = result.stdout.split('\n')
            for port in ports:
                port_str = f":{port}"
                found_connections = [line for line in lines if port_str in line and 'ESTABLISHED' in line]
                
                if found_connections:
                    print_critical(f"Active connections detected on port {port}:")
                    for conn in found_connections[:3]:  # Show first 3
                        parts = conn.split()
                        if len(parts) >= 4:
                            print_info(f"    {parts[1]} -> {parts[2]} (PID: {parts[-1]})")
                            connections.append({
                                'port': port,
                                'local': parts[1],
                                'remote': parts[2],
                                'pid': parts[-1]
                            })
                else:
                    print_success(f"No active connections on port {port}")
        else:
            # Linux/Mac: Use netstat or ss
            result = subprocess.run(
                ["netstat", "-an"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            lines = result.stdout.split('\n')
            for port in ports:
                port_str = f".{port}"
                found_connections = [line for line in lines if port_str in line and 'ESTABLISHED' in line]
                
                if found_connections:
                    print_critical(f"Active connections detected on port {port}:")
                    for conn in found_connections[:3]:
                        print_info(f"    {conn.strip()}")
                        connections.append({'port': port, 'connection': conn.strip()})
                else:
                    print_success(f"No active connections on port {port}")
    
    except Exception as e:
        print_warning(f"Could not check network connections: {e}")
    
    return connections


def check_debug_directories() -> List[str]:
    """Check for common Chrome debug profile directories"""
    print_header("Checking for Debug Profile Directories")
    
    import os
    
    debug_dirs = []
    common_paths = [
        "C:\\temp\\chrome-debug",
        "C:\\tmp\\chrome-debug",
        "/tmp/chrome-debug",
        os.path.expanduser("~/chrome-debug"),
        os.path.expanduser("~/.chrome-debug")
    ]
    
    for path in common_paths:
        if os.path.exists(path):
            print_warning(f"Debug directory found: {path}")
            try:
                # Check when it was last modified
                mtime = os.path.getmtime(path)
                mtime_str = datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M:%S')
                print_info(f"    Last modified: {mtime_str}")
                debug_dirs.append(path)
            except Exception:
                debug_dirs.append(path)
        else:
            print_success(f"No debug directory at: {path}")
    
    return debug_dirs


def generate_report(open_ports: List[int], port_info: List[Dict], 
                   processes: List[Dict], connections: List[Dict], 
                   debug_dirs: List[str]):
    """Generate a summary report of findings"""
    print_header("DETECTION SUMMARY REPORT")
    
    # Calculate risk level
    risk_score = 0
    if open_ports:
        risk_score += 40
    if processes:
        risk_score += 30
    if connections:
        risk_score += 20
    if debug_dirs:
        risk_score += 10
    
    # Determine risk level
    if risk_score >= 70:
        risk_level = f"{Colors.RED}CRITICAL{Colors.RESET}"
        risk_description = "Active Chrome debugging detected - immediate investigation required!"
    elif risk_score >= 40:
        risk_level = f"{Colors.YELLOW}MEDIUM{Colors.RESET}"
        risk_description = "Chrome debugging configuration detected - verify if authorized"
    else:
        risk_level = f"{Colors.GREEN}LOW{Colors.RESET}"
        risk_description = "No active debugging detected - system appears secure"
    
    print(f"\n{Colors.BOLD}Risk Level: {risk_level} (Score: {risk_score}/100){Colors.RESET}")
    print(f"{Colors.BOLD}Assessment: {risk_description}{Colors.RESET}\n")
    
    print("Findings:")
    print(f"  • Open debugging ports: {len(open_ports)}")
    print(f"  • Suspicious Chrome processes: {len(processes)}")
    print(f"  • Active debug connections: {len(connections)}")
    print(f"  • Debug profile directories: {len(debug_dirs)}")
    
    if risk_score >= 40:
        print(f"\n{Colors.RED}{Colors.BOLD}RECOMMENDED ACTIONS:{Colors.RESET}")
        print(f"{Colors.YELLOW}1. Investigate all Chrome processes with debug flags{Colors.RESET}")
        print(f"{Colors.YELLOW}2. Check if debugging is authorized for development/testing{Colors.RESET}")
        print(f"{Colors.YELLOW}3. Verify no malware has modified Chrome shortcuts or registry{Colors.RESET}")
        print(f"{Colors.YELLOW}4. Review network connections for suspicious activity{Colors.RESET}")
        print(f"{Colors.YELLOW}5. Implement monitoring for future detection{Colors.RESET}")
        
        if connections:
            print(f"\n{Colors.RED}⚠ CRITICAL: Active connections detected - potential active exploitation!{Colors.RESET}")


def suggest_mitigations():
    """Provide mitigation and monitoring recommendations"""
    print_header("MITIGATION & MONITORING RECOMMENDATIONS")
    
    print(f"\n{Colors.BOLD}Preventive Measures:{Colors.RESET}")
    print("  1. Block port 9222 at the firewall level")
    print("  2. Implement endpoint monitoring for Chrome debug flags")
    print("  3. Use application whitelisting to prevent unauthorized Chrome launches")
    print("  4. Regular security awareness training for developers")
    print("  5. Network segmentation for development environments")
    
    print(f"\n{Colors.BOLD}Detection & Monitoring:{Colors.RESET}")
    print("  1. Continuous port scanning for 9222, 9223, 9224, 9225")
    print("  2. Process monitoring for '--remote-debugging-port' flag")
    print("  3. Network IDS rules for Chrome DevTools Protocol traffic")
    print("  4. File integrity monitoring for Chrome shortcuts/registry keys")
    print("  5. Scheduled execution of this detection script")
    
    print(f"\n{Colors.BOLD}Incident Response:{Colors.RESET}")
    print("  1. Immediately kill suspicious Chrome processes")
    print("  2. Collect memory dumps for forensic analysis")
    print("  3. Review recent authentication logs for compromised accounts")
    print("  4. Force password resets for potentially affected users")
    print("  5. Scan for additional indicators of compromise")
    
    print(f"\n{Colors.BOLD}PowerShell Detection Script (Windows - for scheduled tasks):{Colors.RESET}")
    print(f"{Colors.CYAN}")
    print("  # Add to your SIEM or monitoring tool:")
    print("  $chromeProcs = Get-Process chrome -ErrorAction SilentlyContinue")
    print("  foreach ($proc in $chromeProcs) {")
    print("    $cmdline = (Get-CimInstance Win32_Process -Filter \"ProcessId = $($proc.Id)\").CommandLine")
    print("    if ($cmdline -match '--remote-debugging-port') {")
    print("      Write-Warning \"Debug Chrome detected: PID $($proc.Id)\"")
    print("      # Send alert to SIEM")
    print("    }")
    print("  }")
    print(f"{Colors.RESET}")
    
    print(f"\n{Colors.BOLD}Shell Script (Linux/MacOS - for cron jobs):{Colors.RESET}")
    print(f"{Colors.CYAN}")
    print("  #!/bin/bash")
    print("  # Add to cron or your monitoring tool:")
    print("  # Example: */5 * * * * /path/to/chrome_debug_monitor.sh")
    print("  ")
    print("  ps aux | grep -E 'chrome|chromium' | grep -E '\\-\\-remote-debugging-port' | grep -v grep | while read line; do")
    print("    pid=$(echo \"$line\" | awk '{print $2}')")
    print("    echo \"[WARNING] Debug Chrome detected: PID $pid\" >&2")
    print("    # Send alert to SIEM or logger:")
    print("    # logger -t chrome_debug_alert \"Debug Chrome process detected: PID $pid\"")
    print("    # curl -X POST https://your-siem.com/api/alert -d \"{\\\"pid\\\": $pid}\"")
    print("  done")
    print("  ")
    print("  # Alternative: Check specific ports")
    print("  for port in 9222 9223 9224 9225; do")
    print("    if netstat -an 2>/dev/null | grep -q \".$port.*LISTEN\" || \\")
    print("       ss -ln 2>/dev/null | grep -q \":$port.*LISTEN\"; then")
    print("      echo \"[CRITICAL] Debug port $port is OPEN\" >&2")
    print("      # Send alert")
    print("    fi")
    print("  done")
    print(f"{Colors.RESET}")


def main():
    """Main detection workflow"""
    print_banner()
    print_info(f"Scan started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print_info(f"Platform: {platform.system()} {platform.release()}\n")
    
    # Step 1: Scan for open debugging ports
    open_ports = scan_debug_ports()
    
    # Step 2: Analyze any open ports
    port_info = []
    for port in open_ports:
        info = analyze_debug_port(port)
        port_info.append(info)
    
    # Step 3: Detect Chrome processes with debug flags
    processes = detect_chrome_processes()
    
    # Step 4: Check network connections
    connections = []
    if open_ports:
        connections = check_network_connections(open_ports)
    
    # Step 5: Check for debug directories
    debug_dirs = check_debug_directories()
    
    # Step 6: Generate report
    generate_report(open_ports, port_info, processes, connections, debug_dirs)
    
    # Step 7: Provide mitigation guidance
    suggest_mitigations()
    
    # Final banner
    print(f"\n{Colors.CYAN}{'=' * 70}")
    print("Detection Scan Complete")
    print(f"{'=' * 70}{Colors.RESET}\n")
    
    # Return exit code based on findings
    if open_ports or processes:
        return 1  # Findings detected
    return 0  # All clear


if __name__ == "__main__":
    import sys
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print(f"\n\n{Colors.YELLOW}[!] Scan interrupted by user{Colors.RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Colors.RED}[-] Unexpected error: {e}{Colors.RESET}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

